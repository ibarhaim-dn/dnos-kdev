#! /bin/bash -e

print_help()
{
    cat >&2 <<MSG
$(basename "$0"): Kernel tool for dnos

This run kernel debug tools inside a docker container

Options:
--------

-h, --help                      Show this message
-n, --dry-run                   Just print what would be done
-r, --ssh-remote HOST           SSH destination (dnos port 2222)
-s, --sourcedir SRC             Kernel source dir (only for kpatch).
--extra-args-docker ARGS        Extra arguments for docker run
--extra-args-stap ARGS          Extra arguments for stap
--extra-args-staprun ARGS       Extra arguments for staprun
--extra-args-stapmod ARGS       Extra arguments for stap module
-u, --match-uidgid              Match current uid/gid

Subcommands:
------------

run
    Run shell command inside the container (default is interactive shell
stap
    Run stap in container with correct -r argument
remote-staprun
    Build stap.ko inside container and run on --ssh-remote
kpatch-build
    Run kpatch-build inside the container
prepare-source
    Prepare kernel given via --sourcedir.

Default is to run an interactive shell.

Subcommands with automatically receive "correct" arguments to reference the
target kernel so \`stap\` is equivalent to \`run stap -r $kver\`
MSG
}

parse_args()
{
    # Defaults
    opt_do_build="1"
    opt_extra_args=()
    opt_extra_args_docker=()
    opt_extra_args_stap=()
    opt_extra_args_staprun=()
    opt_extra_args_stapmod=()
    opt_sourcedir=

    # Does not change easily:
    kver=4.15.0-23-generic

    # Scan args
    local LONG_OPTS=\
"help,\
do-build,no-build,\
ssh-remote:,\
sourcedir:,\
extra-args-docker:,\
extra-args-stap:,\
extra-args-staprun:,\
extra-args-stapmod:,\
match-uidgid,\
dry-run"

    if [[ $OSTYPE = darwin* ]]; then
        if [[ -x /usr/local/opt/gnu-getopt/bin/getopt ]]; then
            getopt() { /usr/local/opt/gnu-getopt/bin/getopt "$@"; }
        fi
    else
        echo >&2 "Need gnu getopt"
        exit 2
    fi

    local opts
    opts=$(getopt -n "$0" -l "$LONG_OPTS" -o +nhr:s:u -- "$@")
    eval set -- "$opts"
    while [ $# -gt 0 ]; do
        case "$1" in
        -h|--help) print_help; exit 1 ;;
        -n|--dry-run) opt_dry_run=1 ;;
        --do-build) opt_do_build=1 ;;
        --no-build) opt_do_build=0 ;;
        -r|--ssh-remote) shift; opt_ssh_remote=$1 ;;
        -s|--sourcedir) shift; opt_sourcedir=$1 ;;
        --extra-args-docker) shift; opt_extra_args_docker+=($1) ;;
        --extra-args-stap) shift; opt_extra_args_stap+=($1) ;;
        --extra-args-staprun) shift; opt_extra_args_staprun+=($1) ;;
        --extra-args-stapmod) shift; opt_extra_args_stapmod+=($1) ;;
        -u|--match-uidgid) opt_match_uidgid=1 ;;
        --)
            if [[ $# == 1 ]]; then
                opt_subcmd="run"
                opt_extra_args=(bash)
            else
                shift
                opt_subcmd="$1"
                shift
                opt_extra_args=("$@")
                break
            fi
            ;;
        *)
            echo >&2 "unrecognized argument $1"
            exit 2
            ;;
        esac
        shift
    done
}

dry_wrap()
{
    if [[ ${opt_dry_run:-0} == 1 ]]; then
        printf >&2 "DRY:%s\n" "$(printf " %q" "$@")"
        return 0
    else
        printf >&2 "RUN:%s\n" "$(printf " %q" "$@")"
        "$@"
        return $?
    fi
}

dry_wrap_exec()
{
    if [[ ${opt_dry_run:-0} == 1 ]]; then
        printf >&2 "DRY EXEC:%s\n" "$(printf " %q" "$@")"
        exit 0
    else
        printf >&2 "EXEC:%s\n" "$(printf " %q" "$@")"
        exec "$@"
    fi
}

docker_build()
{
    (
        dry_wrap cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/ubuntu-bionic-docker"
        dry_wrap docker build . -t "$DOCKER_IMAGE"
    )
}

docker_run()
{
    dry_wrap docker run "${DOCKER_ARGS[@]}" "${opt_extra_args_docker[@]}" "$DOCKER_IMAGE" "$@"
}

prepare_source()
{
    echo >&2 "assume $(printf %q "$opt_sourcedir") is kernel source accessible from docker"
    docker_run cp /usr/src/linux-headers-$kver/scripts/ubuntu-retpoline-extract-one "$opt_sourcedir/scripts/"
    docker_run cp /boot/config-$kver "$opt_sourcedir/.config"
}

main()
{
    parse_args "$@"
    export DOCKER_IMAGE="dnos-kdev-bionic:latest"
    if [[ $opt_do_build == 1 ]]; then
        docker_build
    fi

    # mount currently working directory
    DOCKER_ARGS+=(-v "$PWD:/mnt/cwd")
    DOCKER_ARGS+=(--workdir /mnt/cwd)

    if [[ $opt_match_uidgid == 1 ]]; then
        DOCKER_ARGS+=(--user "$(id -u):$(id -g)")
    fi

    case "$opt_subcmd" in
    run)
        DOCKER_ARGS+=(-i -t)
        docker_run "${opt_extra_args[@]}"
        ;;
    prepare-source)
        if [[ -z $opt_sourcedir ]]; then
            echo "Need --sourcedir"
            exit 1
        fi
        prepare_source
        ;;
    kpatch-build)
        DOCKER_ARGS+=(-v ~/.kpatch:/root/.kpatch)
        # debian scripts pass an explicit KERNELVERSION= argument to make to
        # override the kernel version. Do the same through MAKEFLAGS in order
        # to match modmagic.
        export MAKEFLAGS="KERNELVERSION=$kver $MAKEFLAGS"
        DOCKER_ARGS+=(-e MAKEFLAGS)
        args=(
            --vmlinux /usr/lib/debug/boot/vmlinux-"$kver"
            --config /boot/config-"$kver"
        )
        if [[ -n $opt_sourcedir ]]; then
            args+=(--sourcedir "$opt_sourcedir")
        fi
        docker_run kpatch-build "${args[@]}" "${opt_extra_args[@]}"
        ;;
    stap)
        DOCKER_ARGS+=(-v /root/.systemtap:/root/.systemtap)
        docker_run stap -r"$kver" "${opt_extra_args_stap[@]}" "${opt_extra_args[@]}"
        ;;
    remote-staprun)
        DOCKER_ARGS+=(-v /root/.systemtap:/root/.systemtap)
        stap_modname="stap"
        stap_modfile="$stap_modname.ko"
        docker_run stap -r"$kver" -p4 -m "$stap_modname" "${opt_extra_args_stap[@]}" "${opt_extra_args[@]}"
        remote_tmpdir="/tmp/"
        dry_wrap scp "$stap_modfile" "$opt_ssh_remote:$remote_tmpdir"
        dry_wrap_exec ssh -t "$opt_ssh_remote" staprun \
                "${opt_extra_args_staprun[@]}" \
                "$remote_tmpdir/$stap_modfile" \
                "${opt_extra_args_stapmod[@]}"
        ;;
    *)
        echo >&2 "unknown subcmd $opt_subcmd"
        exit 2
        ;;
    esac
}

main "$@"
